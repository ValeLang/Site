<imports />

<page ns="c-blog" path="blog/zero-cost-refs-regions">
<main>
<title>Vision for the Cross-Platform Core</title>
<subtitle>Seamless Speed, Safety, and Reuse Without Frameworks</subtitle>

<date-and-author date="October 4th, 2020" author="Evan Ovadia" />

                

<section>
  <p>App development is one of the fastest-growing areas of software engineering today. There are <a href="https://www.statista.com/statistics/330695/number-of-smartphone-users-worldwide/">3.5 billion smartphone users</a> in the world, using <a href="https://buildfire.com/app-statistics/">2.2 million</a> App Store apps and <a href="https://buildfire.com/app-statistics/">2.8 million</a> Play Store apps. Many of those have counterparts on the web, too.</p>

  <p>Most app developers write separate code for Android, iOS, and web, resulting in <b>triple</b> the amount of code.</p>

  <p>Empires have risen and fallen trying to solve this problem, but they all have drawbacks. The world is looking for a way to share fast code without the usual language barriers.</p>

  <p>Every good language has one thing that it can do better than any others. This post will show how Vale's unique blend of single ownership and aliasing makes it the perfect language for cross-platform code, and the only language that can bring truly native speed to all three platforms.</p>

  <p>These are planned features. Now that Vale has reached version 0.1, we can start exploring this combination of seamless cross-compilation and the native shared core.</p>
</section>

<h2 className={ns("noline")}>Shared Code</h2>

<section>
  <p>There's two main strategies for sharing code today: use a framework or make a shared core.</p>
</section>


<h3 className={ns("noline")}>Frameworks</h3>

<section>

  <p>The most common approach to sharing code between platforms is to use some sort of garbage collected language in a framework that abstracts away all the details. Ionic, React Native, Flutter, Xamarin, and Unity all try to do this.</p>

  <p>If your application doesn't need anything super special, these can work well. Unfortunately, they use <a href="https://thoughtbot.com/blog/examining-performance-differences-between-native-flutter-and-react-native-mobile-development">more battery life and CPU</a>, lag behind the latest features offered by their OS, and the quirks in the underlying platforms leak through their abstractions and cause bugs. It's amazing they've accomplished what they have, given the challenge they face. As the great <a href="https://news.ycombinator.com/item?id=21502267">nwallin aptly put it,</a> "Cross platform UI is probably the hardest problem in software engineering."</p>

</section>

<h3 className={ns("noline")}>Shared Core</h3>

<section>
  <p>The other approach is to use a <b>shared core.</b> In this approach, we have a thin platform-specific UI layer which calls into a shared "business logic" common library.</p>
</section>

<h4 className={ns("noline")}>Transpiling a GC'd Shared Core</h4>

<section>
  <p>JVM languages are making some strides here. <a href="https://kotlinlang.org/docs/reference/native-overview.html">Kotlin Native</a> and <a href="http://www.scala-native.org/en/v0.3.9-docs/">Scala Native</a> both compile to native machine code which uses garbage collection. They have a bit of a performance ceiling, but they do their job well! <n>jit</n></p>

  <p>One can also transpile Java straight to objective-C. <a href="https://developers.google.com/j2objc/guides/projects-that-use-j2objc">j2objc</a> is the tool that cross compile's the Java code to make the iOS apps for GMail, Chat, Calendar, Docs, and others. Instead of using a garbage collector, it compiles to objective-C, which is <a href="https://yalantis.com/blog/is-swift-faster-than-objective-c/">a bit slower</a>, and the transpiled Java code can leak if it makes any reference cycles. <n>weak</n></p>

  <p>These solutions has some great benefits, and will still be the best approach for some cases. However, there's a big aspect where we can do even better: performance!</p>
</section>

<h4 className={ns("noline")}>Using a Native Shared Core</h4>

<section>

  <p>Experienced app developers will tell you: performance is important. Code can take some time to do something, and past a certain threshold, the user notices. Users, especially on iOS, have very high standards, and that slight bit of lag can turn their delight into discontent.</p>

  <p>Performance helps the user, and it also helps battery life. Users notice when a certain app uses a lot of battery life, and users don't appreciate an app draining their battery needlessly.</p>

  <p>And sometimes, we want performance because we have a lot of calculations to do! Mobile gaming isn't the only performance-hungry kind of app; apps that manipulate a sizeable amount of data like maps, spreadsheets, images, or apps that have a lot of complex applicate state will need every bit of performance they can get their hands on.</p>

  <p>Historically, performance comes with difficulty. In today's most widely used languages, one often has to make a choice between <b>easy but slow</b> (e.g. Python, Javascript) and <b>fast but difficult</b> (e.g. C++, Rust), and there's not much inbetween. However, with the advent of languages like Lobster, Cone, and Vale, we'll soon have languages that are incredibly fast and also very easy.</p>

  <p>Many companies have turned to C++ (<a href="https://slack.engineering/libslack-the-c-library-at-the-foundation-of-our-client-application-architecture-97470b5ef9b3">Slack</a>, <a href="https://web.dev/earth-webassembly/">Earth</a>, <a href="https://dropbox.tech/mobile/the-not-so-hidden-cost-of-sharing-code-between-ios-and-android">Dropbox</a>), which is <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/swift-gpp.html">much faster</a>. We can say from our own experiences that it's a headache to communicate back and forth between C++ and JVM languages, and it's very difficult for people to learn C++.</p>

  <p>This is where Vale can shine: native speed, and easy interop with the host language.</p>
</section>

<h2 className={ns("noline")}>Vale's Approach</h2>

<section>
  <p>Vale's unique blend of single ownership, regions, and high-level design makes it able to both cross-compile to JVM and iOS, and seamlessly drop down into native code for speed.</p>
</section>

<h3 className={ns("noline")}>Cross-Compilation with Optimizability</h3>

<section>
  <p>Most high-level languages, such as Java/Javascript/Python, completely abstract away the details of how objects are represented in memory, and give us no way to optimize, but also lets the language cross-compile (for example, from Java to JS). On the other end, there's languages like C/C++/Rust/Zig/Nim, which expose raw memory and give us the ability to optimize.</p>

  <p><b>Vale is the best of both worlds:</b>it lets us write faster code with keywords like <c>inl</c>, <n>inl</n> which are ignored for environments that don't support that optimization, without changing the semantics of the program.</p>

  <p>Another example: specifying the allocation strategy (heap, bump, pool, etc) <n>regions</n> is similarly ignored in environments that don't support them, and the program will still behave correctly.</p>
  
  <p>Vale is high-level enough to work on all environments, yet gives us tools to write incredibly efficient code.</p>
</section>

<h3 className={ns("noline")}>Features Compile According to Environment</h3>

<section>
  <p>Some features of Vale are chosen to be more optimal depending on the environment they're in. For example:</p>
  <ul>
    <li><c>weakable</c> objects, which allow weak references to point to them:</li>
    <ul>
      <li>In native environments, they have a pointer to a "weak ref count" integer or a "generation" number, depending on the region.</li>
      <li>In JVM or JS, they have a reference to a simple object with a back-pointer pointing back at it.</li>
    </ul>
    <li>Interface references:</li>
    <ul>
      <li>In native environments, these are represented as a "fat pointer" struct containing a pointer to the object and a pointer to a vtable.</li>
      <li>In JVM, these are plain references, and the object itself has the vtable pointer.</li>
    </ul>
  </ul>
</section>

<h3 className={ns("noline")}>Universal Semantics</h3>

<section>
  <p>Vale is a language based on single ownership. Single ownership traditionally means that there's one reference is an "owning" reference, and when it goes away, the object is deallocated. Vale's single ownership is more general; single ownership <b>tracks responsibility</b> to eventually call a certain method, <n>raii</n> more akin to linear types.</p>

  <p>Native, garbage collected, and reference-counted environments all benefit from single ownership. <n>dispose</n> In native environments, destroying an owning reference will also free an object, but in non-native environments, they don't have to, and can still be used for other purposes.</p>
</section>


<h3 className={ns("noline")}>Seamless Communication</h3>

<section>
  <p>Today's languages don't let us have references between native code and the host environment (JVM, iOS, JS), and we often have to construct entire layers of infrastructure to route information to where it needs to go.</p>

  <p>In Vale, we can use regions to express to the compiler which objects are in the native environment, and which objects are in the host environment, and <b>a function can have references to both at the same time.</b></p>

  <p>This makes it incredibly easy to, for example, have a Javascript button call into a Vale presenter when it's clicked. The Javascript button will call into the Vale-transpiled code, which knows how to communicate across the boundary.</p>
</section>

<h3 className={ns("noline")}>How does it work?</h3>

<section>
  <p>Depending on the native code's kind of region, this can work in different ways. We use certain tables in <a href="https://en.wikipedia.org/wiki/Thread-local_storage">thread-local storage</a> to serve as our references into native memory.</p>

  <p>In native memory, there will be:</p>
  <ul>
    <li>Native Constraint Ref Table: <n>shared</n> <c>Map<u64, [ &Any, int ]></c>. The &Any is a regular borrow reference to an object, and the int is how many times we've "locked" this object to prevent its deletion.</li>
    <li>Native Weak Ref Table: <c>Map<u64, &&Any></c>. The dead ones are eventually cleaned up by constant-time incrementing a rabbit pointer. <n>rabbit</n></li>
    <li>An owning reference pointing into native memory will also use the Native Constraint Ref Table.</li>
  </ul>


  <p>In JVM memory, there will be a:</p>
  <ul>
    <li>Java Constraint Ref Table: <c>Map<u64, [ Object, int ]></c> <n>shared2</n></li>
    <li>Java Weak Ref Table: <c>Map<u64, ObjectWeakBox></c></li>
    <li>Java Owning Ref Table: <c>Map<u64, Object></c></li>
  </ul>

</section>

<h3 className={ns("noline")}>Let's see it in action!</h3>

<section>
  <p>Now we'll show what this could look like. Keep in mind, this is still very theoretical, and the syntax will likely be improved.</p>

  <p>Here we're using 'core to refer to the native side and 'host to refer to the JVM side, these are defined by the user elsewhere.</p>
</section>

<split>
  <half>
    <p>This is a function that will run on the JVM.</p>
    <ul>
      <li><c>spaceship</c> is compiled to a long, which is an index into the global Native Constraint Ref Table.</li>
      <li><c>e</c> is a regular Java click event.</li>
      <li><c>callback</c> is a regular Java <c>Func1<Bool, Void></c>.</li>
    </ul>
    <p>Calling flyTo here will:</p>
    <ul>
      <li>Serialize <c>e.location</c> into a buffer.</li>
      <li>Give callback a spot in the Java Constraint Ref Table, and remember the index.</li>
      <li>JNI call into _flyto_wrapper, which takes:</li>
      <ul>
        <li>u64 spaceshipID</li>
        <li>char[] loc</li>
        <li>u64 callbackID</li>
      </ul>
      <li>which will...</li>
      <li>Get a constraint ref for spaceshipID from the Native Constraint Ref Table.</li>
      <li>Deserialize <c>loc</c>.</li>
      <li>Call <c>flyTo</c>.</li>
    </ul>
  </half>
  <half>
<vale>
fn launch(
    spaceship 'core &Spaceship,
    e ClickEvent,
    callback ICallback) // change to fn(bool)void
'host {

  dist = e.spaceship.loc.distance(loc);
  println("Flying " + dist + " parsecs!");
  spaceship.flyTo(e.location, callback);
}
</vale>
  </half>
</split>


<split>
  <half>
    <p>This code is compiled to native assembly.</p>
    <ul>
      <li><c>spaceship</c> is a normal native constraint ref.</li>
      <li><c>loc</c> is a normal native Loc.</li>
      <li><c>callback</c> is compiled to a u64, an index into the Java Constraint Ref Table.</li>
    </ul>
  </half>
  <half>
<vale>
fn flyTo(
    ship &Spaceship,
    loc Loc,
    callback 'platform ICallback) // change to fn(bool)void
'core {
  if (ship.fuel < ship.loc.distance(loc)) {
    callback(false);
  } else {
    mut spaceship.target = loc;
    mut spaceship.fuel = spaceship.fuel - 10; // change to mut spaceship.fuel -= 10;
    mut spaceship.flyingCallback = callback;
  }
}
</vale>
  </half>
</split>


<split>
  <half>
    <p>This struct is compiled in both worlds.</p>

    <p>The <c>distance</c> function here is also compiled to both worlds.</p>

    <p>Since this is a normal struct without any region annotations, it can be compiled to both sides. There will be a native version of <c>distance</c> which works on native <c>Loc</c>s, and a JVM version of <c>distance</c> that works on JVM <c>Loc</c>s.</p>
  </half>
  <half>
<vale>
struct Loc imm {
  x Int;
  y Int;

  fn distance(this Loc, that Loc) {
    sqrt(sq(this.x - that.x) + sq(this.y - that.y))
  }
}
</vale>
  </half>
</split>


<split>
  <half>
    <p>This struct is compiled in native only.</p>

    <p>JVM can still have a reference to it (perhaps through the Tables), but there's no JVM Spaceship class.</p>
  </half>
  <half>
<vale>
struct Spaceship 'core {
  fuel Int;
  loc! Loc;
  target! Loc;
  callback 'platform ICallback; // change to fn(bool)void;
}
</vale>
  </half>
</split>

<p>Vale can call seamlessly into native code, with only a few annotations.</p>

<p>The crown jewel here is that we can make some functions, like <c>distance</c> above, compiled to both JVM and native. This minimizes the number of times we cross the JNI boundary, and avoids a lot of unnecessary JNI calls for tiny one-off functions like getters.</p>

<p>Vale's combination of high-level and fast gives it the unique ability to live in both worlds. Vale is a language that doesn't fear the boundary, but <i>thrives</i> on it. Code can fluidly change between native and host, enabling amazing performance for our apps.</p>


</main>

<margin>

<Note name="weak">
  Once one can identify the memory leak, they can break reference cycles by annotating their code with @Weak.
</Note>

<Note name="jit">
  JVM languages rely on Just-in-Time (JIT) compilation for speed, but Apple doesn't allow JIT on iOS. A cross-compiled JVM language will unfortunately not be as fast on iOS as it is on Android, because of the lack of JIT.
</Note>

<Note name="inl">
  The compiler is intelligent and will put objects on the stack whenever possible, but the user can use the <c>inl</c> keyword to force it. The <c>inl</c> keyword would be obeyed on native, but ignored on JVM or JS.
</Note>

<Note name="regions">
  See <a href="/blog/zero-cost-refs-regions">Zero-Cost References with Regions</a> for more about regions and how they can drastically speed up a program.
</Note>

<Note name="raii">
  See <a href="/blog/raii-next-steps">The Next Steps for Single Ownership and RAII</a> for more about how single ownership is about <i>much</i> more than just freeing memory.
</Note>

<Note name="shared">
  If these are in a shared buffer (JVM "native memory"), then both sides can reach into it. That will be useful for incrementing/decrementing that count.
</Note>

<Note name="shared2">
  We might have this int be in a shared buffer instead, so we can increment/decrement it quickly from both sides.
</Note>

<Note name="dispose">
  For example, adding single ownership to Java or JS would guarantee that you never forget to call <c>.dispose()</c>, <c>.unregister()</c>, <c>.close()</c>, <c>.resolve(x)</c> methods ever again. See <a href="/blog/raii-next-steps">The Next Steps for Single Ownership and RAII</a> for more on this.
</Note>

<Note name="rabbit">
  See <a href="https://medium.com/@tuvo1106/the-tortoise-and-the-hare-floyds-algorithm-87badf5f7d41">The Tortoise and the Hare (Floydâ€™s Algorithm)</a>.
  </Note>

{/*<Note name="otherplans">
  <p>Vale has some other tricks up its sleeve too:</p>
  <ul>
    <li>Accelerated Weak Tables, to reduce weak references' cache misses.</li>
    <li>"Fast Resilient Mode" which won't use ref-counting or borrow-checking for its memory safety, at the cost of slightly more memory usage.</li>
  </ul>
  <p>We'll be posting about these by early next year, but feel free to come by the <a href="https://discord.gg/SNB8yGH">Vale discord</a> and ask about it before then!</p>
</Note>*/}

</margin>
</page>
