---
title: Introduction
path: guide/introduction
layout: annotated
namespace: m-annotated
series-name: Vale Language Guide
series-entry: []()
series-entry: [Structs](/guide/structs)
series-entry: [References](/guide/references)
series-entry: [Interfaces](/guide/interfaces)
series-entry: [Generics](/guide/generics)
series-entry: [Patterns](/guide/patterns)
series-entry: [Regions](/guide/regions)
series-entry: [Externs and Exports](/guide/externs)
---

Welcome to Vale! Vale is a fast, safe, and simple programming language. This introduction will show how to write a program in Vale.

This reference assumes that you are familiar with basic programming concepts, and at least one other imperative language (like C, Java, Python, etc).

Vale is still "in alpha", which means it's a preview; you can write programs in it, but some of the features that make it easy aren't yet available.


# Hello world!

<<<<
Run the code to the right [#running] to see it produce the output in the gray box.
////
```vale
exported func main() {
  println("Hello world!");
}
```stdout
Hello world!
```: `import stdlib.*;`
>>>>


# Locals

<<<<
We can make a local with the `=` symbol.

By default, a local is "final". A final local cannot be changed after it's made.
////
```vale
exported func main() {
  x = "world!";
  println("Hello " + x);
}
```stdout
Hello world!
```: `import stdlib.*;`
>>>>

<<<<
We can change a local's contents with the `set` keyword.
////
```vale
exported func main() {
  x = "world!";
  set x = "Antarctica!";
  println("Hello " + x);
}
```stdout
Hello Antarctica!
```: `import stdlib.*;`
>>>>

<slice>
#running: You can put the code into e.g. `hello.vale` and invoke the compiler with `python3 valec.py build hello.vale`. (After 0.1, it will simply be `vale build hello.vale`.)

That will produce an executable named `hello.exe` (on Windows) or `hello` (on Mac or Linux).
</slice>


# Static Typing & Inference

Vale is a [statically typed](https://stackoverflow.com/questions/1517582/what-is-the-difference-between-statically-typed-and-dynamically-typed-languages) language, which means the type of every local and member is known at compile-time.


<<<<
In this example, `a` is a `str`. We can even specify it after the local's name.

...though we usually leave it out, because Vale uses type inference to figure out the type of `a` for us.
////
```vale
exported func main() {
  a str = "world!";
  println("Hello " + a);
}
```stdout
Hello world!
```: `import stdlib.*;`
>>>>

<slice/>


# Functions

<<<<
Here we have a simple function that `ret`urns the argument plus two.
////
```vale
func add2(x int) int {
  ret x + 2;
}
exported func main() {
  println("Half-Life " + add2(1));
}
```stdout
Half-Life 3
```: `import stdlib.*;`
>>>>

<<<<
If we use the `infer-ret` keyword, Vale will automatically figure out the return type of the function. [# `infer-ret` should be used sparingly, as it increases compile times.]
////
```vale
func add2(x int) infer-ret {
  ret x + 2;
}
```: `exported func main() {}`
>>>>

<<<<
If a block has only one line, we can leave off the `ret` and the semicolon.
////
```vale
func add2(x int) int { x + 2 }
```: `exported func main() {}`
>>>>

<<<<
We can also make a *lambda*, a function inside another one. [# See the Tuples section below for an example of how lambdas are super useful.]
////
```vale
exported func main() {
  add2 = (x int) => { x + 2 };
  println("Half-Life " + add2(1));
}
```: `import stdlib.*;`
>>>>

<<<<
We can leave the type off of a lambda's parameter, to make it shorter. [# Taking out the parameter's type makes this a "generic" lambda, see [generics](/guide/generics) for more.]
////
```vale
exported func main() {
  add2 = (x) => { x + 2 };
  println("Half-Life " + add2(1));
}
```: `import stdlib.*;`
>>>>

<<<<
We can shorten lambdas with the *almighty underscore*, which declares and immediately uses an implicit parameter.
////
```vale
exported func main() {
  add2 = { _ + 2 };
  println("Half-Life " + add2(1));
}
```: `import stdlib.*;`
>>>>

<<<<
In Vale, functions and methods are the same thing, [#ufcs] so these two calls are exactly equivalent. [# Include vstl/list.vale for the `split` function.]
////
```vale
exported func main() {
  s1 = "Hail Hydra!".split(" ");
  s2 = split("Hail Hydra!", " ");
}
```: `import stdlib.*; import stdlib.stringutils.*; import stdlib.collections.*;`
>>>>

<slice>
#ufcs: This is known as Universal Function Call Syntax. This makes method chaining nicer, for example

`a.f(3).g(true).h("Yendor")`

as opposed to

`h(g(f(a, 3), true), "Yendor")`.
</slice>


# Tuples

<<<<
A tuple is a simple struct, whose members are named 0, 1, 2, etc.

We can make a tuple in Vale with parentheses (like `(5, true, 42)`), and can access them with a dot like `arr.0`.
////
```vale
exported func main() {
  arr = (5, true, 42);
  println("Babylon " + arr.0);
}
```stdout
Babylon 5
```: `import stdlib.*;`
>>>>

<slice/>


# Loops

<<<<

We can loop with the `foreach` statement:

////

```vale
exported func main() {
  foreach x in range(0, 3) {
    println(x);
  }
}
```stdout
0
1
2
```: `import stdlib.*; import stdlib.math.*;`

>>>>

<slice/>


# Lists

<<<<

We can make a list with the `List` function. [# Vale's lists are like C#'s `List`, Java's `ArrayList` or C++'s `vector`; it's an array list, not a linked list.]

////

```vale
exported func main() {
  l = List<int>();
  l.add(1);
  l.add(3);
  l.add(7);
  foreach x in l { println(x); }
}
```stdout
1
3
7
```: `import stdlib.collections.*;`
>>>>

<<<<

When iterating, we can also get the index of the current iteration with the `entries()` function.

////

```vale
exported func main() {
  l = List<int>();
  l.add(1);
  l.add(3);
  l.add(7);
  foreach [i, x] in l.entries() {
    println(i + ": " + x);
  }
}
```stdout
0: 1
1: 3
2: 7
```: `import stdlib.*; import stdlib.collections.*;`
>>>>

<slice/>



# Arrays

One doesn't often need arrays because Lists are easier, but arrays can be faster occasionally.


There are two kinds of arrays in Vale:

 * Static-sized arrays, where the size is known at compile time.
 * Runtime-sized arrays, where the size is known only at run time.


## Static-sized Arrays

<<<<

If you know size is known at compile-time, then you can make a static-sized array with the `[#][...]` syntax.

////
```vale
exported func main() {
  arr = [#][1, 3, 7];
  foreach x in arr { println(x); }
}
```stdout
1
3
7
```: `import stdlib.*;`
>>>>

<slice/>


## Runtime-sized Arrays

<<<<

A runtime-sized array is like a List, except its _capacity_ cannot change.

To make a runtime-sized array, we use the `[]type(capacity)` syntax:

 * `[]` means we're making a runtime-sized array.
 * The `type` parameter is the type of the elements.
 * The `capacity` parameter is how many elements this array can hold.


////
```vale
exported func main() {
  n = stdinReadInt(); «inputInt»
  arr = []int(n); «arrtype2»
  foreach i in range(0, n) {
    push(&arr, i * 5);
  }
  foreach i in range(0, n) {
    println(arr[i]);
  }
}
```stdin
3
```stdout
0
5
10
```: `import stdlib.*; import stdlib.math.*; import stdlib.stdin.*;`
>>>>



<<<<

We can also populate it with a function, with the `[]type(capacity, func)` syntax.

The `func` will be called for each element.

In this example, `{_ * 5}` is the function that will populate the array.

////
```vale
exported func main() {
  n = stdinReadInt();
  arr = [](n, {_ * 5});
  foreach i in range(0, n) {
    println(arr[i]);
  }
}
```stdin
3
```stdout
0
5
10
```: `import stdlib.*; import stdlib.math.*; import stdlib.stdin.*;`
>>>>


<slice new-color="afterword">
#inputInt: `stdinReadInt` reads an integer from the user's keyboard. In this example, the user is entering 3.

stdinReadInt is temporary and experimental, expect the stdin/stdout API to change soon.

#arrtype2: The type of `arr` here is `[]int`.
</slice>


# Planned Features

These are planned features for Vale. See the [roadmap](/roadmap) for plans!


## Variants

<<<<
We'll be able to produce a *variant*, which is something that can be one of two types (or more).

To make a variant, use an if-statement, and return a different type from the then branch than the else branch.

Here, `a` is a variant, either a string or an integer. `a`'s type is `(str|int)`.
////
```
exported func main() {
  a =
    if (true) { "hello" }
    else { 42 };
}
```
>>>>

Later, we can use the `match` statement to determine if `a` actually contains a `str` or an `int`.


## Indexing Structs or Tuples for Variants

<<<<
We'll be able to access a arbitrary fields of tuples or structs with square brackets, like `arr[1 + 1]`, which would produce a *variant*. [#variantindexing]
////
```
exported func main() {
  arr = [5, true, "V"];
  println("Saturn " + arr[1 + 1]);
}
```stdout
Saturn V
```
>>>>

<slice new-color="default">
#variantindexing: Specifically, indexing this tuple gives a variant `(int|bool|str)`, with a `+` function that calls the appropriate actual `+` depending on the run-time type (`int` vs `bool` vs `str`).
</slice>

