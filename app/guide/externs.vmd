---
title: Externs and Exports
path: guide/externs
layout: annotated
namespace: m-annotated
series-name: Vale Language Guide
series-entry: [Introduction](/guide/introduction)
series-entry: [Structs](/guide/structs)
series-entry: [References](/guide/references)
series-entry: [Interfaces](/guide/interfaces)
series-entry: [Generics](/guide/generics)
series-entry: [Patterns](/guide/patterns)
series-entry: [Regions](/guide/regions)
series-entry: []()
---


# Extern Functions

Vale can call functions written in other languages, such as C. These "external" functions are known as `extern` functions.

<<<<
Here, `main` is calling out into an external C function that reads an int from the keyboard.

The `fn readInt() int extern;` is telling Vale that the C code will declare a function named `readInt`.

The C code must declare the function with `extern`, so it's visible to Vale.
////
```vale
fn main() export {
  i = readInt();
  println("User entered: " + i);
}
fn readInt() int extern;
```c
#include <stdint.h>
#include <stdio.h>
extern int64_t readInt() {
  int64_t x = 0;
  scanf("%lld", &x);
  return x;
}
```stdin
42
```stdout
User entered: 42
```: `import stdlib.src.*;`
>>>>


# Export Functions

The above Vale code called into a C function. The opposite is also possible, C code can call into Vale code. These Vale functions are known as `export` functions.

<<<<
Here, a Vale `main` is calling into a C `cMain` function, which is calling into a Vale `export`ed `triple` function.

Vale automatically provides a header file so C can call the function. 
////
```vale
fn cMain() extern;
fn main() export { cMain(); }

fn triple(x int) int export {
  x * 3
}
```c
#include <stdint.h>
#include <stdio.h>
#include "triple.h"
extern void cMain() {
  printf("%d", triple(14));
}
```stdout
42
```
>>>>



# Structs

Recall that a struct can either be an `inst`ance or `shared`. The default is `inst`ance. These offer different benefits when calling into (or from) outside code.


## Immutable Structs

When we send an immutable struct from Vale into C, we're actually sending a *copy*. [# Instance structs do not incur this cost. More on that below!]

<<<<
Here, a Vale `main` function is sending an immutable `Mat3` struct into C.

The C code should include "Vec3.h", which is generated by the Vale compiler.

////
```vale
struct Vec3 export imm {
  x int; y int; z int;
}
fn main() export {
  v = Vec3(10, 11, 12);
  s = sum(v);
  println(s);
}
fn sum(v Vec3) int extern;
```c
#include <stdint.h>
#include "Vec3.h"
extern int sum(Vec3* v) {
  return v->x + v->y + v->z;
}
```stdout
33
```: `import stdlib.src.*;`
>>>>


## Mutable Structs

We can give C a mutable struct too.

C will receive an "opaque handle", something that points to the struct, but C cannot read its members. It must ask a Vale function to read any members.

The benefit of using mutable structs in externs is that Vale doesn't have to copy the entire thing when we give it to C.

<<<<
Here, a Vale `main` function is giving C a reference to a `Ship`.

The C function `halfFuel` is then asking the Vale function `getFuel` what the contained fuel is, so C can do its calculation, and return the result.

////
```vale
struct Ship export {
  fuel int;
}
fn getFuel(s &Ship) int export {
  s.fuel
}
fn main() export {
  s = Ship(42);
  h = halfFuel(&s);
  println(h);
}
fn halfFuel(s &Ship) int extern;
```c
#include <stdint.h>
#include "Ship.h"
#include "getFuel.h"
extern int halfFuel(ShipRef s) {
  return getFuel(s) / 2;
}
```stdout
21
```: `import stdlib.src.*;`
>>>>



<slice/>
